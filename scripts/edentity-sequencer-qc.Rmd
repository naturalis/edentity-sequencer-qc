---
header-includes:
   - \usepackage{color}
title: \textcolor{red}{eDentity Sequencer Qc}

date: "`r format(Sys.time(), '%d/%m/%y')`"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,  message=FALSE,warning=FALSE)
```

```{r}
library(ggplot2)
library(scales)
library(forcats)
library(tidyverse)

```

## 1.1.1 Percentage of bases >= Q30

Metric: Calculate the fraction of bases whose Phred score are greater or equal to Q30.

```{r}

# function to fix misssing commas
fix_csv_commas <- function(input_file, output_file) {
  #  Read the CSV file line by line
  lines <- readLines(input_file)
  
  # Fix lines that have missing commas
  fixed_lines <- sapply(lines, function(line) {
    num_commas <- length(strsplit(line, ",")[[1]]) - 1
    
    # Assuming each row should have 2 commas (for 3 columns)
    if (num_commas == 1) {
      return(paste0(line, ","))   # Add one missing comma
    } else if (num_commas == 0) {
      return(paste0(line, ",,"))  # Add two missing commas
    } else {
      return(line)  # If correct, no change
    }
  })
  
  # Write the fixed lines to the output file
  writeLines(fixed_lines, output_file)
  
  # Return confirmation or any additional actions if needed
  message("CSV has been fixed and saved to: ", output_file)
}

# Example usage:
# fix_csv_commas("input_file.csv", "fixed_file.csv")

#fix missing comma

fix_csv_commas("../results/elements-1.1.1-qc.txt", "../results/elements-1.1.1-qc-fixed.csv")
fix_csv_commas("../results/illumina-1.1.1-qc.txt", "../results/illumina-1.1.1-qc-fixed.csv")


```


```{r}

#extract average q30 fraction
get_mean_q30 <- function(q30_file){
    # read the data
    df <- read.csv(q30_file, header = F)
    colnames(df)[1:3] <- c("file", "n_reads", "q30.fraction")
    df <- subset(df, select = c("file", "n_reads", "q30.fraction"))
    df <- na.omit(df)
    df$scaled_q30 <- df$n_reads * df$q30.fraction
    
    sum_scaled <- sum(df$scaled_q30) / sum(df$n_reads)
    return(sum_scaled)
  }


q30_df<- data.frame(
          Illumina = get_mean_q30("../results/illumina-1.1.1-qc-fixed.csv"),
          Elements = get_mean_q30("../results/elements-1.1.1-qc-fixed.csv")
          )

knitr::kable(q30_df,  align="lr", digits = 2)
```



## 1.1.2 Read Length Retension after Q30 Trimming (Percentage).

Metric: (Average length after trimming / original read length ) $\times$ 100

```{r}
get_length_retention <- function(untrimmed_stast_file, trimmed_stats_file) {
  
  
  untrimmed_len_stats <- read.csv(untrimmed_stast_file, sep = "\t")
  trimmed_len_stats <- read.csv(trimmed_stats_file, sep = "\t")
  
  return(
    mean(as.numeric(na.omit(trimmed_len_stats$avg_len))) / 
      mean(as.numeric(na.omit(untrimmed_len_stats$avg_len))) * 100
    )
}


length_df <- data.frame(Illumina = get_length_retention(
                                      "../results/illumina-stats.tsv",
                                      "../results/trimmed-illumina-stats.tsv"),
                        
                        Elements = get_length_retention(
                                      "../results/elements-stats.tsv",
                                      "../results/elements-trimmed-stats.tsv"))

knitr::kable(length_df,align="lr", digits = 2)
```

## Total Number of reads.

This section looks at the total number of reads as received from the sequencer

```{r}
illumina_stats_df <- read.csv("../results/illumina-stats.tsv", sep = "\t")
# add pair
illumina_stats_df$read_pair <- ifelse(grepl("R1", illumina_stats_df$file),"R1", 
                                      ifelse(grepl("R2", 
                                                   illumina_stats_df$file), "R2", NA))

# add sample name and marker name
illumina_stats_df$sample <- sapply(strsplit(illumina_stats_df$file, "_R[12]_"), `[`, 1)
illumina_stats_df$marker <- sapply(strsplit(illumina_stats_df$file, "_"), `[`, 1)


# same steps for elements

#write.table(illumina_stats_df,"../results/illumina-file-stats.tsv")
#dim(illumina_stats_df)

elements_stats_df <- read.csv("../results/elements-stats.tsv", sep = "\t")
# add pair, sample and marker info
elements_stats_df$read_pair <- ifelse(grepl("R1", elements_stats_df$file), "R1", ifelse(grepl("R2", elements_stats_df$file), "R2", NA))
elements_stats_df$sample <- sapply(strsplit(elements_stats_df$file, "_R"), `[`, 1)
elements_stats_df$marker <- sapply(strsplit(elements_stats_df$file, "_"), `[`, 3)
 

```


```{r}
raw_totals <- data.frame(
                            # sum of all reads 
                            total_reads = c( sum(illumina_stats_df[illumina_stats_df$read_pair == "R1",]$num_seqs),
                                        sum(illumina_stats_df[illumina_stats_df$read_pair == "R2",]$num_seqs),
                                        sum(elements_stats_df[elements_stats_df$read_pair == "R1",]$num_seqs),
                                        sum(elements_stats_df[elements_stats_df$read_pair == "R2",]$num_seqs)),
                            
                            total_files = c( dim(illumina_stats_df[illumina_stats_df$read_pair == "R1",])[1],
                                        dim(illumina_stats_df[illumina_stats_df$read_pair == "R1",])[1],
                                        dim(elements_stats_df[elements_stats_df$read_pair == "R1",])[1],
                                        dim(elements_stats_df[elements_stats_df$read_pair == "R1",])[1]),
                              
                            # average number of reads per file
                            average_reads = c( mean(illumina_stats_df[illumina_stats_df$read_pair == "R1",]$num_seqs),
                                            mean(illumina_stats_df[illumina_stats_df$read_pair == "R2",]$num_seqs),
                                            mean(elements_stats_df[elements_stats_df$read_pair == "R1",]$num_seqs),
                                            mean(elements_stats_df[elements_stats_df$read_pair == "R2",]$num_seqs)),
                            
                            # sequencer info
                            sequencer = c("illumina", "illumina", "elements", "elements"),
                            
                            # pair info
                            read_pair = c("R1", "R2", "R1", "R2"))


knitr::kable(raw_totals,align="lr", digits = 2,format.args = list(big.mark = ","))
```
\newpage
### Total number of reads per marker

```{r}

# drop undertermined reads from illumina
illumina_sample_df <- illumina_stats_df[illumina_stats_df$marker != "Undetermined",]

#markers <- with(illumina_sample_df, reorder(marker, num_seqs, sum))

illumina_markers_df <- illumina_sample_df %>%
  group_by(marker, read_pair) %>%
  summarize(total_sequences = sum(num_seqs), .groups = "drop")


ggplot(illumina_markers_df, aes(x = reorder(marker,total_sequences),
                   y = total_sequences, fill = read_pair)) +
  geom_bar(stat = "identity", position = "dodge") +
  scale_y_continuous(labels = comma)+
  labs(
    title = "Illumina",
    x = "Marker",
    y = "Total Number of Reads for each marker",
    fill = "Read Pair"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
#View(illumina_markers_df)
```

```{r}
#write.table(illumina_markers_df, "../results/illumina-markers-read-numbers.tsv", row.names = F,sep = "\t")
```

```{r}

# filter out Phix and unassigned
exclude_samples <- c("Unassigned", "Adept_CB1", "Adept_CB2", "Adept_CB3", "Adept_CB4")
elements_sample_df <- elements_stats_df[!elements_stats_df$sample %in% exclude_samples, ]


# create a df with total reads per marker
elements_markers_df <- elements_sample_df %>%
  group_by(marker, read_pair) %>%
  summarize(total_sequences = sum(num_seqs), .groups = "drop")

# create a bar plot of the total reads per marker
ggplot(elements_markers_df, aes(x = reorder(marker,total_sequences),
                                y = total_sequences, fill = read_pair)) +
  geom_bar(stat = "identity", position = "dodge") +
  scale_y_continuous(labels = comma)+
  labs(
    title = "Elements",
    x = "Marker",
    y = "Total Number of Reads for each marker",
    fill = "Read Pair"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

## Filter out the Empty, Phix and undetermined reads.

Next we exclude the empty , unassigned as well as sample with "Blank" markers.

Then we look at the number of reads after filtering.


```{r}
# remove empty 
elements_none_empty <- elements_sample_df[elements_sample_df$marker != "Empty",]
illumina_none_empty <- illumina_sample_df[illumina_sample_df$marker != "Empty",]


# exclude blanks
elements_blank_markers <- c("ITS-Blank", "ITSmix-Blank", "SSU-Blank", "LSU-Blank")
illumina_blank_markers <-  c("ITSmix-Blank1","ITSmix-Blank2", "ITSmix-Blank3",
                             "LSU-Blank1", "LSU-Blank2","LSU-Blank3",
                             "SSU-Blank1", "SSU-Blank2", "SSU-Blank3",
                             "ITS-Blank1", "ITS-Blank2", "ITS-Blank3")

illumina_none_empty <- illumina_none_empty[!illumina_none_empty$marker %in% illumina_blank_markers, ]
elements_none_empty <- elements_none_empty[!elements_none_empty$marker %in% elements_blank_markers, ]

# add a column with sequencer info
illumina_none_empty$sequencer <- "llumina"
elements_none_empty$sequencer <- "Elements"

# merge both sequencer dfs for visualization
merged_df <- rbind(illumina_none_empty[,c("file", "num_seqs", "sample", "read_pair", "marker", "sequencer")],
                  elements_none_empty[,c("file", "num_seqs", "sample", "read_pair", "marker", "sequencer")]
                  )




# create a df with average number of reads per file
average_reads <- data.frame(
                            # sum of all reads 
                            total_reads = c( sum(illumina_none_empty[illumina_none_empty$read_pair == "R1",]$num_seqs),
                                        sum(illumina_none_empty[illumina_none_empty$read_pair == "R2",]$num_seqs),
                                        sum(elements_none_empty[elements_none_empty$read_pair == "R1",]$num_seqs),
                                        sum(elements_none_empty[elements_none_empty$read_pair == "R2",]$num_seqs)),
                            
                            total_files = c( dim(illumina_none_empty[illumina_none_empty$read_pair == "R1",])[1],
                                        dim(illumina_none_empty[illumina_none_empty$read_pair == "R1",])[1],
                                        dim(elements_none_empty[elements_none_empty$read_pair == "R1",])[1],
                                        dim(elements_none_empty[elements_none_empty$read_pair == "R1",])[1]),
                              
                            # average number of reads per file
                            average_reads = c( mean(illumina_none_empty[illumina_none_empty$read_pair == "R1",]$num_seqs),
                                            mean(illumina_none_empty[illumina_none_empty$read_pair == "R2",]$num_seqs),
                                            mean(elements_none_empty[elements_none_empty$read_pair == "R1",]$num_seqs),
                                            mean(elements_none_empty[elements_none_empty$read_pair == "R2",]$num_seqs)),
                            
                            # sequencer info
                            sequencer = c("illumina", "illumina", "elements", "elements"),
                            
                            # pair info
                            read_pair = c("R1", "R2", "R1", "R2"))
                            



knitr::kable(average_reads,align="lr", digits = 2,format.args = list(big.mark = ","))
```

What is the distribution of reads per marker after filtering?

```{r}


# reorder the sequencer from lowest n reads to largest
merged_df <- merged_df %>%
  mutate(sequencer = reorder(sequencer, num_seqs, FUN = mean)) 

# Create the violin
ggplot(merged_df, aes(x = sequencer, y = num_seqs, color = marker)) +
  geom_violin(trim = FALSE, alpha = 0.4) + 
  stat_summary(fun.y = mean, geom = "errorbar",linetype = "solid")+
  scale_y_continuous(labels = comma)+
  labs(y = "Number of reads", x = "Sequencer", 
       title = "Distribution of reads per Marker") +
  theme_minimal() +
  theme(legend.position = "right")

###########
## Still thinking how i can show the number of samples per marker

```

## 1.2.1 Hommopolymer Accuracy
Homopolymer sequence: A series of consecutive identical bases— in this case four or more consecutive repeats of the same base. 


Metric: Average Q score decay per additional base in homopolymer runs (e.g AAAA, TTTT) compared to the Phix reference genome.

```{r}
decay <- function(decay_file){
  
            accuracy <- read.csv(decay_file, header = FALSE)
  
            colnames(accuracy) <- c("file",
                                    "total_reads",
                                    "average_decay")
            return(
                  mean(accuracy$average_decay)
                  ) # scale
              }



decay_df <- data.frame(
            Illumina = decay("../results/illumina-1.2.1-homopolymer_decay.csv"),
            Elements = decay("../results/elements-1.2.1-homopolymer_decay.csv")
            )

knitr::kable(decay_df,align="lr", digits = 2)
```
## 1.2.2 Demultiplexing Efficiency (Percentage)

Metric: (Number of reads successfully demultiplexed / Total number of reads) $\times$ 100



|       | **Illumina** |  **Element** |
|-------|---------------|----------|
| Total Reads (without Phix reads) | 662,034,609  | 376,486,325  |
| Demultiplexed Reads| 608,699,786 |  361,464,384 |
| Demultiplexing Efficiency| 91.94 | 96.01 |


```{r}
#demux <- read.csv("../results/illumina-1.2.2-demux.csv")

#total_reads <- sum(demux$Nreads) # should empty be part of totals ?


#n_demultiplexed <-  sum(demux[demux$Category != "Undetermined",]$Nreads)

#efficiency <- n_demultiplexed / total_reads * 100

#demult_df <- data.frame(illumina = efficiency)

#knitr::kable(demult_df, align="lr", digits = 2)

```

\newpage
## 1.2.3 PhiX Control performance

Metric: Assess sequencing quality using spiked-in Phix control


|       | **Illumina** |  **Element** |
|-------|---------------|----------|
|PhiX Error Rate| 0.005588 | 0.007656|
|PhiX Alignment Rate| 0.2520 |  0.2760 |
|**PhiX Coverage Uniformity:** |    |   |
|     - Coefficient of Variation: | 0.1554 | 0.1631|
|     - Percentage within ±20% of mean coverage: | 0.9332 |0.9081|
| **Additional Information:** |   |   |
|     - Total Reads: | 885,110,280 | 520,004,986 |
|     - Mapped Reads: | 223,075,671 | 143,518,661 |
|     - Mean Coverage: | 12,410,202.48 | 7,927,615.76|
|     - Coverage Range: | 1,254,247 - 14,897,715 | 942836 - 9820668|


## 1.2.4 Duplicate Read Rate (Percentage)

Metrics: Percentage of duplicate reads in a standard non-amplified library.

Only reads mapping to Phix were used here under the assumption that Phix is a "standard non-amplified library"

but it appears Phix reads were amplified therefore they may not be a good measure of duplication rate.

|       | **Illumina** |  **Element** |
|-------|---------------|----------|
|Mapped Reads: | 223,075,671 | 143,518,661 |
|Duplicate reads:| 219,577,678 | 138,553,627 |
| Duplicate rate |  0.9843 |   0.9654 |

## 1.2.5 GC Bias 

Metric: Deviation of coverage in GC-rich regions compared to AT-rich regions

Only reads mapping to Phix were used to compute GC Bias



```{r}
gc_bias <- function(gc_bias_file){
    gc_df <- read.csv(gc_bias_file)
    gc_df_ordered <- gc_df[order(-gc_df$GC.Content),]
    
    # coverage at the GC lowest region / coverage at the GC rich region
    coverage_ratio <- 
      gc_df_ordered$Average.Coverage[length(gc_df_ordered$Average.Coverage)]/
      gc_df_ordered$Average.Coverage[length(1)]
    
    return(
     coverage_ratio)
  }

gc_bias_coverage = data.frame(
    Illumina = gc_bias("../results/illumina-1.2.5.csv"),
    Elements = gc_bias("../results/elements-1.2.5.csv")
)

knitr::kable(gc_bias_coverage,align="lr", digits = 2)
```










